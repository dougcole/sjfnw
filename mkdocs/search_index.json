{
    "docs": [
        {
            "location": "/", 
            "text": "Documentation related to development and project maintenance\n\n\n\n\n\nContributing\n\n\nFollow the table of contents to get a local development environment set up, starting with \ninstallation and setup\n.\n\n\nThe \nresources\n page has links with more info on the various languages/platforms/technologies that are used. If you are new to Django, definitely look through the Django docs.\n\n\nCheck \nissues labeled \"ready\"\n to see what needs doing. Post a comment on the issue if you need clarification. See \nissue tracking\n for more info.\n\n\nIf you notice anything missing/wrong in the docs, please submit a PR!", 
            "title": "Home"
        }, 
        {
            "location": "/getting-started/installation-and-setup/", 
            "text": "Instructions assume you're running linux or mac osx and can use a package manager (\nhomebrew\n, \napt-get\n, etc.) as needed.\n\n\nCode\n\n\ngit clone https://github.com/aisapatino/sjfnw.git\n\n\nPython\n\n\nThe project uses python 2.7, which is probably already installed with your OS. Confirm by doing \npython --version\n. Install using package manager if needed.\n\n\nGit\n\n\nMay be installed already, check with \ngit --version\n. Install/update using package manager if needed.\n\n\nMySQL\n\n\nInstall mysql and a python-mysql adapter.\n\n\nLinux: \napt-get install mysql-server python-mysqldb\n\nOSX: \nbrew install mysql\n, \npip install mysql-python\n (you should have \npip\n already, see \nbelow\n if not)\n\n\nWhen prompted, enter the password from \nsjfnw/settings.py\n\n\nOnce those have installed, create the database:\n\n\n\n\nmysql -uroot -p\n to get into the mysql shell. This will prompt you for the password you set when you installed.\n\n\ncreate database sjfdb_local character set utf8 collate utf8_general_ci;\n\n\n\n\nSet up the database\n\n\n./manage.py syncdb\n\n\nYou should see output as tables are created in the local database based on the project's model definitions.\n\nCreate a superuser when prompted - that creates a user account that you can use to log into the admin site on your local server.\n\n\nIf this doesn't work, make sure \nmanage.py\n has execute permissions. \nchmod u+x manage.py\n should work.\n\n\nLoad fixtures\n\n\nTo populate your local db with data:\n\n\n./manage.py load_testing_data\n\n\nGoogle App Engine SDK\n\n\nDownload\n \n unzip (somewhere outside the repo).\n\n\nProject dependencies\n\n\nPrerequisite: \npip\n\n\nYou'll need \npip\n, python's package manager. It is included with python 2.7.9 and above, so you should have it already. Try \npip --version\n.\n\n\nIf you don't have it, you can \ninstall it directly\n or upgrade your python installation.\n\n\nInstall dependencies\n\n\n./scripts/install-libs\n\n\nThis will install everything listed in \nrequirements.txt\n into the \nlibs\n folder.\n\n\nUpdate paths\n\n\nUpdate your \n~/.bashrc\n (or other file depending on the shell you use)\n\n\nexport PATH=$PATH:/[path to gae]\nexport PYTHONPATH=$PYTHONPATH:[path to gae]\nexport PYTHONPATH=$PYTHONPATH:[path to gae]/lib/webob-1.2.3\nexport PYTHONPATH=$PYTHONPATH:[path to repo]/sjfnw/libs\n\n\n\n\nVerify\n\n\nRun \n./scripts/verify-install\n to verify that you've installed everything successfully. It doesn't verify everything (for instance, database setup), but can check the basics. You should see output like this:\n\n\nChecking installation...\n\nPython: 2.7.6 (required: 2.7.x)\npip: 7.1.2 (required: any)\nMysql: 5.5.44 (required: 5.5.x or 5.6.x)\nGoogle AppEngine SDK: Found in PATH and PYTHONPATH\n\nChecking libs...\n  - django: found\n  - pytz: found\n  - unicodecsv: found\n\n\u2714 Basic installation checks passed.", 
            "title": "Installation and setup"
        }, 
        {
            "location": "/getting-started/local-server/", 
            "text": "To start up the local server, (from inside the root of the repo) do\n\n\ndev_appserver.py .\n\n\nIf you get something like 'command not found', make sure GAE is in your path. Use \necho $PATH\n to confirm. See \nsetup\n.\n\n\nCreate accounts\n\n\nThe superuser you created in the \nsyncdb\n step of \nsetup\n gives you access to the admin site. For using the app locally you'll want to be able to log into the fundraising and grant application areas too.\n\n\n\n\nGo to \n/admin-advanced\n* and log in with superuser email \n pw you created when you ran \nsyncdb\n.\n\n\nCreate a \nMember\n object so you can log into the fundraising app:\n\n\nClick on \n+ Add\n next to \nMembers\n\n\nEnter the email you used to log in, and whatever first \n last name you want.\n\n\nHit \nSave\n\n\nGo back to \n/admin-advanced\n to create an \nOrganization\n for yourself:\n\n\nClick on \n+Add\n next to \nOrganizations\n\n\nEnter the same email, fill in whatever other fields are required\n\n\nHit \nSave\n\n\nYou should now be able to log into both sides of the app: \n/fund/login\n and \n/apply/login\n\n\n\n\n* The advanced admin site is only used by devs (and should eventually be replaced with better admin permissions). Staff use \n/admin\n, which you can use most of the time, but for this you need additional access.", 
            "title": "Running a local server"
        }, 
        {
            "location": "/getting-started/running-tests/", 
            "text": "Running tests\n\n\nRun all tests:\n\n\n./manage.py test sjfnw\n\n\nTo get more granular, use python \n.\n-separated paths:\n\n\n./manage.py test sjfnw.[module].tests.[test_file].[TestClass].[test_name]\n\n\nExamples:\n\n\nOnly fundraising tests: \n./manage.py test sjfnw.fund\n\nSpecific test file: \n./manage.py test sjfnw.grants.tests.test_admin\n\nSpecific test suite: \n./manage.py test sjfnw.fund.tests.test_steps.AddStep\n\nSpecific test: \n./manage.py test sjfnw.fund.tests.test_steps.AddStep.test_valid\n\n\nCoverage\n\n\nBrowse code coverage on \ncodecov\n (more info: \nCI\n).\n\n\nTo check test coverage locally, install \ncoverage.py\n, then do\n\n\n./scripts/coverage\n\n\nthen open \n./coverage-html/index.html", 
            "title": "Running tests"
        }, 
        {
            "location": "/getting-started/text-editor-setup/", 
            "text": "There's no particular setup \nneeded\n for this project, but a few tools may be helpful:\n\n\nEditorconfig\n\n\nHelps maintain consistent per-project coding style by automating some of your text editor's settings (indentation in particular) based on the \n.editorconfig\n file. See \neditorconfig.org\n for more info. There are plugins for many editors, including:\n\n\n\n\nSublime\n\n\nVim\n\n\n\n\nPylint plugin\n\n\nShow lint warnings in your editor so you don't need to run the command line script. \nInstall pylint\n first.\n\n\nSublime3\n: \nSublimeLinter\n + \nSublimeLinter-pylint\n\n\nIn your \nuser settings\n, under \n\"linters\"\n, include\n\n\npylint\n: {\n  \nrcfile\n: \n[path to repo]/.pylintrc\n\n}\n\n\n\n\nVim\n: \nsyntastic\n\n\nIn your \n.vimrc\n, include\n\n\nlet g:syntastic_python_checkers = ['pylint']\nlet g:syntastic_python_pylint_args = '--rcfile=[path to repo]/.pylintrc'", 
            "title": "Text editor setup"
        }, 
        {
            "location": "/getting-started/linters/", 
            "text": "The repo is set up to use \npylint\n and \neslint\n, syntax \n style checkers for python and javascript.\n\n\nInstallation\n\n\npylint: \n(recommended)\n\n\n\n\npip install pylint\n (details \nhere\n)\n\n\nmake sure you have v1.4+ (do \npip list\n to see, \npip -U pylint\n to upgrade)\n\n\n\n\n\n\npip install pylint-django\n (\nplugin\n that makes pylint more django friendly)\n\n\n\n\neslint: \n(only if you're doing a lot of javascript work)\n\n\n\n\nInstall \nnode\n, which comes with \nnpm\n (node package manager): \nsudo apt-get install node\n or \nbrew install node\n\n\nSee their \ndocs\n for more info if needed.\n\n\n\n\n\n\nnpm install -g eslint\n will install eslint globally (i.e. always on your path).\n\n\nSee \nthis page\n if you get a permissions error.\n\n\n\n\n\n\n\n\nUsage - in text editor\n\n\nSee \ntext editor setup\n for more info.\n\n\nUsage - CLI\n\n\n\n\nTo lint the whole project: \n./scripts/lint\n\n\nThat will output results to the console. If you want to save results to a file, you can do \n./scripts/lint \n filename.txt\n\n\n\n\nConfiguration\n\n\n\n\n.pylintrc\n , \npylint docs\n\n\n.eslintrc\n , \neslint docs", 
            "title": "Linters"
        }, 
        {
            "location": "/about/models/", 
            "text": "Here is a visual overview of the relationship between models in the app. Note the update date in the image; it may not always reflect the latest changes. For more info:\n\n\n\n\nDjango docs on model relationships\n\n\nSources: \nfund/models.py\n, \ngrants/models.py", 
            "title": "Overview of models"
        }, 
        {
            "location": "/about/project-structure/", 
            "text": "Most of the project structure is determined by Django (more info in \nresources\n).\n\n\nDependencies that aren't provided by Google App Engine are listed in \nrequirements.txt\n and installed into \nlibs/\n via \npip\n. See \nsetup\n for details. Current packages in \nlibs\n are:\n\n\n\n\ndjango\n is included with GAE, but only up to 1.5. We're using 1.8.4 manually instead.\n\n\npytz\n is \nhighly recommended\n by Django for handling time zones/time zone aware datetimes.\n\n\nunicodecsv\n is a pretty small wrapper around python's \ncsv\n module, which \ndoes not support Unicode input\n in 2.7.9. There is some export functionality through the admin site that uses it.", 
            "title": "Project structure"
        }, 
        {
            "location": "/about/code-conventions/", 
            "text": "Consistent code formatting and style makes it easier to read and maintain. This is a work in progress in the current code; existing code is being updated gradually. \nAll new code should follow the guidelines below\n.\n\n\nCode style guidelines\n\n\nGenerally follow google's \nPython style guide\n. A few exceptions/clarifications:\n\n\n\n\n2 space indents  \n\n\nSingle quotes except for docstrings  \n\n\nWe're not as stringent with line length; aim for \n100\n\n\n\n\nSee the \nlinters\n page for information on plugins that check syntax/style. Note that pylint does \nnot\n check quotes or indentation, but should catch most other issues.", 
            "title": "Code conventions"
        }, 
        {
            "location": "/about/docs/", 
            "text": "Documentation\n\n\nThis documentation is kept the \ndocs/\n directory of the \nsjfnw\n repo\n. It is written in markdown, converted to html using \nmkdocs\n, and published using Github Pages.\n\n\nFile structure\n\n\n\n\nmkdocs.yml\n configures mkdocs, including a listing of all the pages, which is used to build the navigation menus.\n\n\ndocs/\n contains the documentation source files. They're grouped into folders to match the way they're grouped in nav.\n\n\ndocs/_theme/\n contains files for customizing the appearance/layout of the html output.\n\n\ndocs/README.md\n shows when you browse \ndocs/\n in the repo\n to point people to the processed version.\n\n\n\n\nUpdates\n\n\n\n\nTo preview the docs site locally, use \nmkdocs serve\n, then go to \nhttp://127.0.0.1:8000/\n. It will automatically update as you make changes.\n\n\nIf you add, remove or rename a file, make sure you update \nmkdocs.yml\n accordingly.\n\n\nmkdocs gh-deploy\n will build and then push to the \ngh-pages\n branch which updates the docs site.", 
            "title": "Documentation"
        }, 
        {
            "location": "/about/docs/#documentation", 
            "text": "This documentation is kept the  docs/  directory of the  sjfnw  repo . It is written in markdown, converted to html using  mkdocs , and published using Github Pages.  File structure   mkdocs.yml  configures mkdocs, including a listing of all the pages, which is used to build the navigation menus.  docs/  contains the documentation source files. They're grouped into folders to match the way they're grouped in nav.  docs/_theme/  contains files for customizing the appearance/layout of the html output.  docs/README.md  shows when you browse  docs/  in the repo  to point people to the processed version.   Updates   To preview the docs site locally, use  mkdocs serve , then go to  http://127.0.0.1:8000/ . It will automatically update as you make changes.  If you add, remove or rename a file, make sure you update  mkdocs.yml  accordingly.  mkdocs gh-deploy  will build and then push to the  gh-pages  branch which updates the docs site.", 
            "title": "Documentation"
        }, 
        {
            "location": "/workflow/git/", 
            "text": "Commits\n\n\n\n\nTry to keep commits granular - group related changes into commits rather than one huge commit at the end\n\n\nFirst line of the commit message should be a short overview of the changes (\n72 chars so it isn't truncated)\n\n\nUse the commit body to give more detail and/or \nlink issues\n if applicable\n\n\n\n\nExample:\n\n\nclean up grant application javascript\n\nremove console.logs, use more description function names\nfixes #43\n\n\n\n\nBranches\n\n\nmaster\n is the main branch. Avoid ever pushing directly to \nmaster\n. Instead, when working on a feature/change, create a new branch:\n\n\ngit checkout master\ngit pull\ngit checkout -b new-branch-name\n\n\n\n\nFor a long-running feature, use a feature branch based off of \nmaster\n. Open PRs/merge into that branch, and base new feature-related branches off of it. Then when the feature is complete, merge that branch into \nmaster\n.\n\n\nPull requests\n\n\nWhen your changes are ready, open a \npull request\n so the code can be reviewed and merged into \nmaster\n.", 
            "title": "Git"
        }, 
        {
            "location": "/workflow/issue-tracking/", 
            "text": "Overview\n\n\nWe use github's built-in issues system to keep track of dev tasks: see \nissues\n tab.\n\n\n\n\nAlways search issues before creating a new one to make sure it hasn't already been filed.\n\n\nEverything that a dev thinks needs to be done or that is requested/suggested by staff/other users is recorded as an issue.\n\n\nIssues are organized using milestones and labels - see below for details. Short version:\n\n\nCurrent active milestone always starts with \u2605\n\n\nPriority labels: \np1\n is highest priority, \np4\n is lowest\n\n\n\n\n\n\nIf you are looking for something to do, check the \nready\n label\n. That's used for tasks that should be ready to work on.\n\n\n\n\nMilestones\n\n\n\n\nThere is always an active milestone for current tasks. It has a due date and always starts with a \u2605 to make it easier to find in the dropdown.\n\n\nThree milestones for broad sorting:\n\n\nBacklog - to do\n tasks that we definitely want to do. Look through this when picking tasks for the active milestone.\n\n\nBacklog - lower priority\n tasks that we'd like to do, but may not get to.\n\n\nFuture ideas\n tasks that are too time consuming and/or not beneficial enough to prioritize. These are often ideas without much definition.\n\n\n\n\n\n\n\n\nLabels\n\n\nLabels are used for more fine-grained categorizing of issues. See the \nlabels\n page for a current list. This may get out of sync, but is meant to provide some explanation for how they're organized.\n\n\nLabels are prefixed so that they are in order in the dropdown, making it easier to apply them. They are often abbreviated so that issues list isn't too cluttered.\n\n\narea:\n  admin            related to the admin site (including custom admin pages like reporting)\n  grants           related to the grant application portal\n  fund             related to the fundraising app\n\nlang(uage):        this is a new set of labels and isn't thoroughly applied yet. it's\n  html/css         intended as a way for potential contributors to identify front-end focused tasks\n  js               that don't involve much python/django\n\n(priority):\n  p1               most important/urgent. definitely should get done\n  p2               important, but not pressing\n  p3               would like to do eventually\n  p4               other ideas, some of which may never be implemented\n\nstatus:\n  archived         closed without fixing/doing\n  staff            waiting on information/direction from staff\n  ready            ready to be worked on (clearly described with links/refs if applicable)\n\ntype:\n  bug              unintended behavior that breaks or interferes with existing functionality\n  dev              development work, may not have an effect from user perspective. ex: code refactors\n  meta             umbrella issue. things like \nfigure out steps to do x\n or \ndesign review\n\n                   will usually not result in code changes, but in more specific tickets\n                   being created\n  feature          add new functionality\n  performance      usually refers to reducing page load\n  tests            related to automated tests\n  ui/ux            improvements to appearance or interaction flow \n\nmobile             (not prefixed) mobile-specific", 
            "title": "Issue tracking"
        }, 
        {
            "location": "/workflow/issue-tracking/#overview", 
            "text": "We use github's built-in issues system to keep track of dev tasks: see  issues  tab.   Always search issues before creating a new one to make sure it hasn't already been filed.  Everything that a dev thinks needs to be done or that is requested/suggested by staff/other users is recorded as an issue.  Issues are organized using milestones and labels - see below for details. Short version:  Current active milestone always starts with \u2605  Priority labels:  p1  is highest priority,  p4  is lowest    If you are looking for something to do, check the  ready  label . That's used for tasks that should be ready to work on.", 
            "title": "Overview"
        }, 
        {
            "location": "/workflow/issue-tracking/#milestones", 
            "text": "There is always an active milestone for current tasks. It has a due date and always starts with a \u2605 to make it easier to find in the dropdown.  Three milestones for broad sorting:  Backlog - to do  tasks that we definitely want to do. Look through this when picking tasks for the active milestone.  Backlog - lower priority  tasks that we'd like to do, but may not get to.  Future ideas  tasks that are too time consuming and/or not beneficial enough to prioritize. These are often ideas without much definition.", 
            "title": "Milestones"
        }, 
        {
            "location": "/workflow/issue-tracking/#labels", 
            "text": "Labels are used for more fine-grained categorizing of issues. See the  labels  page for a current list. This may get out of sync, but is meant to provide some explanation for how they're organized.  Labels are prefixed so that they are in order in the dropdown, making it easier to apply them. They are often abbreviated so that issues list isn't too cluttered.  area:\n  admin            related to the admin site (including custom admin pages like reporting)\n  grants           related to the grant application portal\n  fund             related to the fundraising app\n\nlang(uage):        this is a new set of labels and isn't thoroughly applied yet. it's\n  html/css         intended as a way for potential contributors to identify front-end focused tasks\n  js               that don't involve much python/django\n\n(priority):\n  p1               most important/urgent. definitely should get done\n  p2               important, but not pressing\n  p3               would like to do eventually\n  p4               other ideas, some of which may never be implemented\n\nstatus:\n  archived         closed without fixing/doing\n  staff            waiting on information/direction from staff\n  ready            ready to be worked on (clearly described with links/refs if applicable)\n\ntype:\n  bug              unintended behavior that breaks or interferes with existing functionality\n  dev              development work, may not have an effect from user perspective. ex: code refactors\n  meta             umbrella issue. things like  figure out steps to do x  or  design review \n                   will usually not result in code changes, but in more specific tickets\n                   being created\n  feature          add new functionality\n  performance      usually refers to reducing page load\n  tests            related to automated tests\n  ui/ux            improvements to appearance or interaction flow \n\nmobile             (not prefixed) mobile-specific", 
            "title": "Labels"
        }, 
        {
            "location": "/workflow/continuous-integration/", 
            "text": "Travis CI\n\n\ntravis-ci.org/aisapatino/sjfnw\n\n\nTravis runs tests whenever a new commit is pushed to github. The badge at the top of the README reflects the results of the most recent test run on \nmaster\n\n\nWhen previewing or creating a pull request, there will be icons next to some commits indicating test success or failure on travis. Click to see details.\n\n\nCodecov.io\n\n\ncodecov.io/github/aisapatino/sjfnw\n\n\nTool for tracking test coverage over time. When Travis runs tests, it reports the coverage results and they're recorded at the link above. You can click on a commit to see a breakdown by file, and click on a file to see line-by-line coverage.\n\n\nCodecov is configured to leave a comment on every pull request with the change in code coverage.", 
            "title": "Travis CI & Codecov.io"
        }, 
        {
            "location": "/workflow/deploying/", 
            "text": "Overview of current process: manual deploy with \nappcfg.py\n, then add git tag using the date. Tagging is so we can easily see what exact code is live, and compare it to the last release, in cases where something is going wrong.\n\n\nPrepare for release\n\n\n\n\nMerge the desired change into \nmaster\n.\n\n\nVerify that the changes don't break anything. (This should have been done before merging to \nmaster\n, too)\n\n  a. Make sure all tests pass.\n\n  b. Checkout master locally and test the app; particularly the parts that have been changed.\n\n\n\n\nRelease\n\n\n\n\nTag\n the commit you will be releasing.\n\n\ngit tag -a 2015-08-09 -m \"summary of changes\"\n\n  a. Make sure the first line is under 72 chars like with commit messages.\n\n  b. The message doesn't need to be comprehensive; commit messages and diffs can be used to get the full details.\n\n  c. If it's not the first tag in a day, do \n2015-08-09.2\n etc.\n\n\nDeploy\n\n  a. Make sure you don't have any local uncommitted changes; they will be deployed.\n\n  b. \nappcfg.py -E CLOUDSQL_PASSWORD:[pw] update .\n (from root of repo) to deploy to App Engine.\n\n  c. \ngit push --tags\n to push the release tag.\n\n\nVerify\n that the live site is working.\n\n\n\n\nMore info\n\n\n\n\nappcfg\n\n\ngit tags", 
            "title": "Deploying"
        }, 
        {
            "location": "/tests/intro-to-testing/", 
            "text": "Basics\n\n\nTests generally consist of a combination of actions and assertions. Assertions are used to describe the outcome you expect. If an assertion fails, it will raise an exception, and that test will stop running and be considered 'failed'.\n\n\nDjango testing overview\n has a lot of good information.\n\n\nTypes of tests\n\n\nThere are many terms for types of tests, and they're often used differently by different people. For our purposes, we'll go with some basic definitions:\n\n\nUnit tests\n test a single small piece of your code - for instance, a single method. They shouldn't require dependencies or complex setup - they test a section of code in isolation, essentially. They don't use the test client.\n\n\nFunctional/integration tests\n\nFunctional tests are often defined as verifying a certain function from the user's perspective - e.g. 'When I load this url, I expect to see these things on the page'.  Integration tests are focused on testing that multiple parts of the app work together. For instance, 'If I submit this form, I expect that a new Donor model will be created with these properties.' We tend to go for a combo approach where we test what is in the response as well as what effects that has on the database. These tests take more setup, often use fixtures and usually revolve around http requests though the test client.\n\n\nCurrent state of tests in sjfnw\n\n\nMost of our tests are functional/integrational, focusing on a specific view, often involving at least one form and model. They are the easiest type to write given the way our code is set up and they test a lot of parts of the app. As we refactor some code into smaller pieces, we can write more unit tests, like these ones for \n_compile_membership_progress\n.\n\n\nOnr major issue with our tests is that we don't have any way to test our front-end javascript. There is some key functionality there - things like loading and submitting forms, autosaving the grant application. There's an issue filed \nhere\n.\n\n\nAt this point, the primary goal is to add \ntest coverage\n in whatever ways seem best. In particular, we should \navoid adding any new functionality without accompanying tests\n.\n\n\nDjango and Python testing\n\n\nDjango and Python provide a lot of tools/infrastructure for testing. To start:\n\n\n\n\nDue to our \ndatabase settings\n, the tests will use a sqlite3 database (in-memory and much faster than using a local mysql).\n\n\nA test databases is created at the start and destroyed after all tests have run. Between tests, the database is restored to its prior state, so one test's changes in the db should not affect another test.\n\n\nIf fixtures are specified, they will be loaded into the db before each test.\n\n\n\n\nAll of our test classes inherit from \ndjango.test.TestCase\n, which inherits from Python's \nunittest.TestCase\n. This provides all our test classes with\n\n\n\n\nOptional \nsetUp\n and \ntearDown\n methods, which, if specified, will run before \n after each individual test. \nsetUp\n is often useful, for example for logging the user in before each test.\n\n\nAssertions are provided as methods on the test class. Python provides some \nbasic ones\n and Django adds \nadditional ones\n\n\nDjango provides a \ntest client\n that can make requests\n\n\n\n\nNote: We have sub-classed Django's \nTestCase\n as \nBaseTestCase\n, which is further specialized as \nBaseFundTestCase\n and \nBaseGrantTestCase\n. They just provide a few convenient shortcuts for common tasks like creating a User and logging them in.\n\n\nTest files\n\n\nTests are located in \nsjfnw/fund/tests/\n and \nsjfnw/grants/tests/\n\n- Split tests into separate files by subject\n\n- Files all start with \ntest_\n (to be found by the test runner)\n\n\nsjfnw/tests.py\n houses test-related classes and methods that are useful across both modules. For instance: custom test runner, base test classes, custom assertion methods, etc.\n\n\nOrganizing tests\n\n\nIn Django, test classes represent test suites - bundles of tests that share a \nsetUp\n method, fixtures, etc.\n\n\nfrom sjfnw.fund.tests.base import BaseFundTestCase\n\nclass LoginForm(BaseFundTestCase):\n\n\n\n\nA basic test class can inherit from \ndjango.test.TestCase\n, but more frequently you'll be using the fundraising base test case above, or the one in grants.\n\n\nTest methods have to start with \ntest_\n. Meaning you can include helper methods (not tests themselves, but used by tests) as long as they don't use that prefix.\n\n\nI usually structure it like this:\n\n- A file has tests relating to a theme (\ntest_steps.py\n, \ntest_home.py\n, etc).\n\n- Inside the file, there's a class for each smaller breakdown of the theme, e.g. \nAddStep\n, \nCompleteStep\n, \nEditStep\n\n- If the file gets too long, you can split it into pieces. One class per file or multiple classes per file are ok.\n\n- Each class can have a \nsetUp\n method that runs before \neach\n individual test method.\n\n- Individual test methods test different scenarios related to the same form, model, etc.\n\n\nSee \nwriting tests\n for an in-depth example.", 
            "title": "Intro"
        }, 
        {
            "location": "/tests/writing-tests/", 
            "text": "We'll use the example of login form submission and go through how to start writing tests for it. This is for functional/integration tests.\n\n\nBrainstorm\n\n\nIt's useful to start by brainstorming the various scenarios you want to test and what you want to verify in each case. Let's say the login form has two fields: email address and password. Here are some possible examples of \nPOST\n requests and what you might expect from each.\n\n\n\n\nBlank form\n\n\nUser is not logged in\n\n\nResponse contains login form with 'required' errors on both fields\n\n\n\n\n\n\nOnly email is entered\n\n\nUser is not logged in\n\n\nResponse contains login form with 'required' error on password field\n\n\n\n\n\n\nOnly password is entered\n\n\nUser is not logged in\n\n\nResponse contains login form with 'required' error on email field\n\n\n\n\n\n\nInvalid format for email address\n\n\nUser is not logged in\n\n\nResponse contains login form with 'invalid' error message on email field\n\n\n\n\n\n\nEmail is not registered\n\n\nUser is not logged in\n\n\nResponse contains login form with 'not registered' error message\n\n\n\n\n\n\nEmail is registered, but password is incorrect\n\n\nUser is not logged in\n\n\nResponse contains login form with 'wrong password' error message\n\n\n\n\n\n\nEmail is registered and password is correct (finally!)\n\n\nUser is logged in\n\n\nResponse redirects to another page\n\n\n\n\n\n\n\n\nNotes on tests\n\n\nAs you can see, a few things are often true:\n\n\n\n\nThere are a lot of potential tests for just a two-field form\n\n\nThere's a lot of repetition in the things we need to verify\n\n\nSome of these seem like they should be a given - if we have a field like \nemail = forms.EmailField()\n that covers the 'email should be required' test (since fields are required by default) and the 'email should be a valid email' test (since \nEmailField\n comes with validation).\n\n\n\n\nRe: 1 \n 2: Tests are very verbose and it's common to spend more time writing tests for a change than you spent on the change itself. Some of the offsetting factors are:\n\n- Having each test cover one small scenario makes it much easier to tell what's broken when tests fail\n\n- It's also very tedious to test something manually unless it's a very tiny change\n\n- You have a record of what is \n isn't tested instead of just remembering what you tested manually\n\n- You can reuse these tests after every change, rather than having to re-test things by hand\n\n- The process of writing tests can be helpful in a) clarifying desired behavior and b) catching bugs at the time.\n\n\nRe: 3: Part of the purpose of tests is to assert what the behavior \nshould\n be, so that we'll get a warning if it ever changes. The obvious 'email should be required' test will fail if someone adds \nrequired=False\n to that field for some reason. So it functions as a sort of confirmation dialog when we change something to go against what we had previously said it should do. We're not really testing whether the \nEmailField\n validation works, we're saying that this field of the login form should only accept email addresses.\n\n\n(Also, you'll often be testing more complicated and customized forms than this example)\n\n\nOutline tests\n\n\nYou can write down your brainstorming as a list of empty tests.\n\n\nimport unittest\n\nfrom sjfnw.fund.tests.base import BaseFundTestCase\n\nclass LoginForm(BaseFundTestCase):\n\n  @unittest.skip('Incomplete')\n  def test_missing_password(self):\n    \n Password missing - form error shown, user not logged in \n\n    pass\n\n\n\n\n\n\n@unittest.skip('Incomplete')\n will skip the test, printing out the reason - 'Incomplete', in this case.\n\n\nThe method name should be somewhat descriptive, to make it easy to identify if the test fails.\n\n\nI've recently settled on aiming for a single line docstring that gives an overview of what the test is trying to verify. The details (exact assertions, etc) can be read in the code.\n\n\nNote: I recommend snippets for being able to write out a list of test ideas quickly. (\nSublime\n)\n\n\n\n\nTest setup\n\n\nOften, your tests will share some pre-conditions that you'll want to set up in the class's \nsetUp\n method. For instance, the user may need to be logged in to access the form you want to test, or it may require that certain objects are in the database already. That doesn't apply for this example but see [[Intro to testing|intro-to-testing]] for more info/links.\n\n\nWriting a test\n\n\nA test often has three sections.\n\n\n\n\nVerify the starting state\n\n\nTake an action (e.g. send a \nPOST\n request)\n\n\nVerify the response \n ending state\n\n\n\n\nVerifying can take different forms, including:\n\n- Assert something is/isn't in the database\n\n- Assert the value of a field on a model retrieved from the database\n\n- Assert various attributes of the response: status code, url, redirects, template used\n\n- Assert that something is/isn't in the content of the response\n\n\nAn action of POSTing a form can require some preparation to assemble the mocked form data to send.\n\n\nWhen you're done outlining and want to start on the tests themselves, you fill them in and then remove the \nskip\n decorator.\n\n\nExample test\n\n\nWith extra comments to illustrate:\n\n\nimport unittest\n\nfrom django.contrib.auth.models import User\n\nfrom sjfnw.fund.tests.base import BaseFundTestCase\n\nclass LoginForm(BaseFundTestCase):\n\n  def test_missing_password(self):\n    \n Password missing - form error shown, user not logged in \n\n\n    # ------ 1. verify starting state ------\n\n    # create User\n    User.objects.create_user('abc@gmail.com', 'abc@gmail.com', 'password')\n\n    # ------ 2. take an action - submit form data ------\n\n    # create mock form data\n    form_data = {\n      'email': 'abc@gmail.com',\n      'password': ''\n    }\n\n    # make the request\n    response = self.client.post('/login', form_data, follow=True)\n\n    # ------ 3. verify response and ending state ------\n\n    self.assertTemplateUsed(response, 'fund/login.html')\n\n    # should be {} if user was not logged in, which evaluates to False\n    self.assertFalse(self.client.session)\n\n    # context is the dictionary passed into the render call in the view\n    # this assumes the login form was passed in with the key 'form'\n    errors = response.context['form'].errors\n\n    self.assertEqual(errors['password'], ['This field is required'])\n    self.assertEqual(errors['email'], [])\n\n\n\n\nCheck the \nresources\n page for links to more info about testing.", 
            "title": "Writing tests"
        }, 
        {
            "location": "/tests/fund/", 
            "text": "Brief overview of what is provided to each test class that inherits from \nBaseFundTestCase\n\n\nNOTE\n: It is easy for documentation to get out of sync with code. If anything in here doesn't seem to match the results you're getting, take a look at the source:\n\n\n\n\n\n\n\n\nLocation\n\n\nContains\n\n\n\n\n\n\n\n\n\n\nsjfnw/tests.py\n\n\nBaseTestCase\n\n\n\n\n\n\nsjfnw/fund/base.py\n\n\nBaseFundTestCase\n\n\n\n\n\n\nsjfnw/fund/fixtures/\n\n\nfixtures used by fund tests\n\n\n\n\n\n\n\n\nFixtures\n\n\nBy inheriting, your test will use the fixtures specified by \nBaseFundTestCase\n unless you overwrite that property.\n\n\nsetUp\n creates 2 giving projects\n\n\nUsage:\n\n\n  # inside of your test's setUp method\n  def setUp(self):\n    super(TestClass, self).setUp()\n\n\n\n\nCreates:\n\n    - Post-training GP (Fundraising training date has passed; estimates are required)\n\n    - Pre-training GP (Fundraising training has not happened; estimates not required)\n\n\nTest memberships\n\n\nThese can be used by calling one of the following methods, which create the necessary objects and then log the test user in.\n\n\nUsage:\n\n\n  # call from inside setUp, or in an individual test method\n  self.use_test_acct() # or one of the others listed below\n\n\n\n\ndefault\n means that \nmember.current\n is set to that membership, so it will be used when the user logs into Project Central.\n\n\nTesty - \nuse_test_acct()\n\n\n\n\ntestacct@gmail.com\n User and Member (\nself.member_id\n)\n\n\n2 Memberships:\n\n\nPost-training project (\nself.ship_id\n) \ndefault\n\n\nOne Donor (\nself.donor_id\n) with one incomplete, overdue step (\nself.step_id\n)\n\n\nLGBTQ Giving project (membership id is \n1\n)\n\n\n8 donors\n\n\nSee \nsjfnw/fund/fixtures/testy.json\n for details\n\n\n\n\n\n\n\n\nNewbie - \nuse_new_acct()\n\n\n\n\nnewacct@gmail.com\n User and Member (\nself.member_id\n)\n\n\n2 Memberships:\n\n\nPre-training (\nself.pre_id\n) \ndefault\n\n\nPost-training (\nself.post_id\n)\n\n\n\n\n\n\nNo Donors\n\n\n\n\nAdmin - \nuse_admin_acct()\n\n\n\n\nUser with email \nadmin@gmail.com\n that is a superuser\n\n\nNo Member or Organization object associated; this one is just for testing admin site features.", 
            "title": "Fundraising tests"
        }, 
        {
            "location": "/how-to/debugging-performance/", 
            "text": "Django Debug Toolbar\n:\n\n\n\n\nThe Django Debug Toolbar is a configurable set of panels that display various debug information about the current request/response\n\n\n\n\nIt is a good tool for examining the time it takes to make a request - in particular, for looking at what queries are made and how much time they're taking up. Queries are shown in the console if you use \n--log-level debug\n but this is a much more readable format, and shows information about timing.\n\n\nSetup\n\n\n\n\nInstall: \npip install django-debug-toolbar\n\n\nMake sure it is on your path; to install it somewhere specific add \n-t [target directory]\n \n\n\nIf it installs django as a dependency, delete it; otherwise it will try to use that instead of the version you already have installed (and the versions may be different).\n\n\n\n\n\n\nConfigure: In settings.py, uncomment the django debug toolbar config\n\n\nCopy static files: \ncp -r [install location]/static/debug_toolbar [sjfnw repo]/sjfnw/static\n\n\nCurrently, we don't do any build step, which the toolbar expects in order to serve its static assets, so copying is a quick hacky way to make it work\n\n\nMake sure to avoid committing the copied static files\n\n\n\n\n\n\n\n\nThere is surely a better way to enable usage of the toolbar, but that's what I've done so far\n\n\nUse\n\n\nRun your local server and load a page. You'll see a panel on the right side. Click a section for details. Check their \ndocs\n for details.\n\n\nThe main thing to look at is queries:\n\n\n\n\nLook at the total time compared to the SQL time to see if queries are a major part of the page load time.\n\n\nLook for redundant or unnecessary queries\n\n\nQueries that aren't being used\n\n\nRepeats of the same query\n\n\nSimilar queries that could be combined\n\n\nQueries for related objects that could be combined", 
            "title": "Performance debugging"
        }, 
        {
            "location": "/how-to/database/", 
            "text": "Migrations (changes to models)\n\n\nWhenever you add/change/delete a model or a model field, you should add a migration. See the docs for \nmigration workflow\n. Short version:\n\n\n\n\nMake the change in your local code\n\n\nRecord the change: \n./manage.py makemigrations\n. Preferably, use \n-n\n to give it a descriptive name.\n\n\nUpdate your local database: \n./manage.py migrate\n will run the migration you created.\n\n\nRun local server and verify that it doesn't crash.\n\n\nAdd/update tests as needed, verify that all tests are passing\n\n\nAlways put the model change and the new migration file in the same commit.\n\n\n\n\nSee the linked docs for more detail on migrations and the commands used.\n\n\nBackground\n\n\nSee \nsjfnw/settings.py\n where databases are configured.\n\n\n\n\nTesting\n: \nsqlite3\n, a local, in-memory, super fast db. It is managed automatically by the testing framework. See \nintro to testing\n for more info.\n\n\nLocal server\n: Local \nmysql\n instance. See \ninstallation and setup\n.\n\n\nProduction\n: The deployed app uses a CloudSQL database, which is basically a hosted MySQL.\n\n\n\n\nConnecting to MySQL\n\n\n\n\n\n\nConnect to a mysql instance from the command line\n\n  local: \nmysql -uroot -p\n\n  remote: \nmysql --host=111.111.111.111 -uroot -p\n\n\n-uroot\n means sign in as the user 'root'\n\n\n-p\n means prompt for password\n\n\n-host\n specifies the IP of the remote host (replace with actual IP)\n\n\nEvery time you connect to CloudSQL from a different IP address, you'll need to adjust permissions as described below.\n\n\n\n\n\n\nUse the app's database\n\n\n\n\n\n\nlocal: \nuse sjfdb_local;\n\n  remote: \nuse sjfdb;\n\n\nCloudSQL permissions\n\n\nTo connect to CloudSQL, you need to configure it to allow connections from your IP address.\n\n\n\n\nFind your ip address. Googling 'my ip' works.\n\n\nConvert it to CIDR notation: use \nthis tool\n and enter your IP in both fields.\n\n\nTake the output and enter it in the \nCloudSQL console\n under 'Allowed Networks'", 
            "title": "Database management"
        }, 
        {
            "location": "/how-to/database/#migrations-changes-to-models", 
            "text": "Whenever you add/change/delete a model or a model field, you should add a migration. See the docs for  migration workflow . Short version:   Make the change in your local code  Record the change:  ./manage.py makemigrations . Preferably, use  -n  to give it a descriptive name.  Update your local database:  ./manage.py migrate  will run the migration you created.  Run local server and verify that it doesn't crash.  Add/update tests as needed, verify that all tests are passing  Always put the model change and the new migration file in the same commit.   See the linked docs for more detail on migrations and the commands used.", 
            "title": "Migrations (changes to models)"
        }, 
        {
            "location": "/how-to/database/#background", 
            "text": "See  sjfnw/settings.py  where databases are configured.   Testing :  sqlite3 , a local, in-memory, super fast db. It is managed automatically by the testing framework. See  intro to testing  for more info.  Local server : Local  mysql  instance. See  installation and setup .  Production : The deployed app uses a CloudSQL database, which is basically a hosted MySQL.", 
            "title": "Background"
        }, 
        {
            "location": "/how-to/database/#connecting-to-mysql", 
            "text": "Connect to a mysql instance from the command line \n  local:  mysql -uroot -p \n  remote:  mysql --host=111.111.111.111 -uroot -p  -uroot  means sign in as the user 'root'  -p  means prompt for password  -host  specifies the IP of the remote host (replace with actual IP)  Every time you connect to CloudSQL from a different IP address, you'll need to adjust permissions as described below.    Use the app's database    local:  use sjfdb_local; \n  remote:  use sjfdb;  CloudSQL permissions  To connect to CloudSQL, you need to configure it to allow connections from your IP address.   Find your ip address. Googling 'my ip' works.  Convert it to CIDR notation: use  this tool  and enter your IP in both fields.  Take the output and enter it in the  CloudSQL console  under 'Allowed Networks'", 
            "title": "Connecting to MySQL"
        }, 
        {
            "location": "/how-to/support-requests/", 
            "text": "Info \n procedure for common support requests.\n\n\nOnline grant application\n\n\nForgotten password\n\n\nDo they still have access to the same email address they used to sign up?\n\n- If so, direct them to https://sjf-nw.appspot.com/apply/reset where they can reset their password.\n\n- If not, see below.\n\n\nUpdating email address used to log in\n\n\nOnce you've located the organization in the admin site, and have the new email address that they want to use:\n\n\n\n\nUpdate email on User and reset the password\n\n\nCan search by email address or organization name. (Most/all orgs should have org name under \"first name\")\n\n\nUse the link near the top of the edit page to reset their password.\n\n\nUpdate the \nusername\n and \nemail\n fields to the new address\n\n\n\n\nSave\n\n\n\n\n\n\nUpdate email on Organization\n\n\n\n\nUpdate the \nLogin\n field at the top to the new email address.\n\n\nScroll down to 'Add a log entry' and enter a note saying that what you changed the email from \n to. Under 'contacted' put the name of the person that made the request.\n\n\n\n\nSave\n\n\n\n\n\n\nEmail them\n\n\n\n\nInclude the new email and password\n\n\nInclude the reset password link so they can change the password from the one you set", 
            "title": "Support requests"
        }, 
        {
            "location": "/resources/", 
            "text": "Git\n\n\nIncludes a good \ncheatsheet\n\n\n\n\n\n\nPython\n\n\nTestCase and assertions\n\n\nRegular expressions\n\n\nGoogle's python style guide\n (see \ncode conventions\n)\n\n\n\n\n\n\nDjango\n\n\nNote: If you google something you'll often wind up at the most recent docs. Make sure you're looking at the docs version that matches the version we're using (see requirements.txt for current version)\n\n\nTutorial\n\n\nModels\n\n\nViews\n\n\nForms\n\n\nTemplates\n\n\nAdmin site\n\n\nIntro to testing\n \n(See Python's TestCase docs above for more info)\n\n\nTesting overview\n (including \nassertions\n)\n\n\n\n\n\n\nGoogle App Engine\n\n\nNote: Much of the GAE docs don't apply to this project since we use Django\n\n\napp.yaml\n is the GAE app config file\n\n\nThe project's \ncron tasks\n use GAE\n\n\n\n\n\n\nMySQL\n reference/tutorial\n\n\nCSS: \nIntro\n, \nReference\n\n\nHTML guide\n\n\nIntro to HTTP and REST", 
            "title": "Resources"
        }
    ]
}